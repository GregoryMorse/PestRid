#include "stdafx.h"
#include <winternl.h>
#include "Resource.h"
#include "Utility.h"

int CStringCmp(const void* pvLeft, const void* pvRight)
{
	return _tcsicmp(((CString*)pvLeft)->GetString(),
					((CString*)pvRight)->GetString());
}

void EliminateDupStrings(CStringArray & Strings, BOOL bSort)
{
	//removal cost is large if a lot of duplicates and union operation would be more efficient
	DWORD dwCount;
	if (bSort) {
		//if sort then lookup cost is qsort + n string comparisons
		qsort(Strings.GetData(), Strings.GetCount(), sizeof(CString), CStringCmp);
		for (dwCount = 0; dwCount < (DWORD)Strings.GetCount() - 1; dwCount++) {
			if (Strings[dwCount].CompareNoCase(Strings[dwCount + 1]) == 0) {
				Strings.RemoveAt(dwCount + 1);
				dwCount--;
			}
		}
	} else {
		//if no sort then lookup cost is n string hashings
		CMapStringToPtr DupMap;
		LPCTSTR rKey;
		for (dwCount = 0; dwCount < (DWORD)Strings.GetCount(); dwCount++) {
			if (DupMap.LookupKey(Strings[dwCount], rKey)) {
				Strings.RemoveAt(dwCount);
			} else DupMap.SetAt(Strings[dwCount], NULL);
		}
	}
}

void StringArrayFromLPTSTRS(TCHAR* pStrs, CStringArray& Strings)
{
	TCHAR* pcBuffPtr;
	size_t sLen;
	pcBuffPtr = pStrs;
	while ((sLen = _tcslen(pcBuffPtr)) != 0) {
		Strings.Add(pcBuffPtr);
		pcBuffPtr += sLen + 1;
	}
}

void StringArrayFromLPWSTRS(WCHAR* pStrs, CStringWArray & Strings)
{
	WCHAR* pcBuffPtr;
	size_t sLen;
	pcBuffPtr = pStrs;
	while ((sLen = wcslen(pcBuffPtr)) != 0) {
		Strings.Add(CStringW(pcBuffPtr));
		pcBuffPtr += sLen + 1;
	}
}

void LPTSTRSFromStringArray(CStringArray& Strings, CByteArray & Bytes)
{
	DWORD dwLen = 0;
	DWORD dwCount;
	for (dwCount = 0; dwCount < (DWORD)Strings.GetCount(); dwCount++) {
		dwLen += Strings[dwCount].GetLength() + 1;
	}
	Bytes.SetSize((dwLen + 1) * sizeof(TCHAR));
	dwLen = 0;
	for (dwCount = 0; dwCount < (DWORD)Strings.GetCount(); dwCount++) {
		_tcscpy((TCHAR*)Bytes.GetData() + dwLen, Strings[dwCount]);
		dwLen += Strings[dwCount].GetLength() + 1;
	}
	*((TCHAR*)Bytes.GetData() + dwLen) = 0;
}

void UniStringToCStringW(UNICODE_STRING* ustr, CStringW & Str)
{
	if (ustr->Buffer) {
		wcsncpy(Str.GetBuffer(ustr->Length), ustr->Buffer, ustr->Length);
		Str.ReleaseBuffer(ustr->Length / sizeof(WCHAR));
	} else {
		Str.Empty();
	}
}

void RemoveTrailingBackslash(CString & String)
{
	if (String[String.GetLength() - 1] == '\\')
		String.SetAt(String.GetLength() - 1, 0);
}

CString GetHexBytes(BYTE* pbBytes, DWORD dwLength)
{
	int iCount;
	CString Str;
	for (	iCount = 0; (DWORD)iCount < dwLength; iCount++) {
		Str.AppendFormat(iCount == dwLength - 1 ? _T("%02X") : _T("%02X "), pbBytes[iCount]);
	}
	return Str;
}

CString GetAsciiBytes(BYTE* pbBytes, DWORD dwLength)
{
	int iCount;
	CString Str;
	for (	iCount = 0; (DWORD)iCount < dwLength; iCount++) {
		Str += pbBytes[iCount] < 0x20 ? ' ' : (char)pbBytes[iCount];
	}
	return Str;
}

#include <atlsecurity.h>
#include "DisplayTypes.h"
#include "Utility.h"
#include "WinAPI.h"
#define _SETUPAPI_VER _WIN32_WINNT_LONGHORN //_WIN32_WINNT_WINXP
#include <SetupAPI.h>
#define REMOTE_BOOT
#include <regstr.h>
#include <cfgmgr32.h>

//
// Define Device Object (DO) flags
//
#define DO_VERIFY_VOLUME                0x00000002      
#define DO_BUFFERED_IO                  0x00000004      
#define DO_EXCLUSIVE                    0x00000008      
#define DO_DIRECT_IO                    0x00000010      
#define DO_MAP_IO_BUFFER                0x00000020      
#define DO_DEVICE_HAS_NAME              0x00000040      
#define DO_DEVICE_INITIALIZING          0x00000080      
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      
#define DO_LONG_TERM_REQUESTS           0x00000200      
#define DO_NEVER_LAST_DEVICE            0x00000400      
#define DO_SHUTDOWN_REGISTERED          0x00000800      
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      
#define DO_POWER_PAGABLE                0x00002000      
#define DO_POWER_INRUSH                 0x00004000      
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000

//
// Define the various device characteristics flags
//

#define FILE_REMOVABLE_MEDIA            0x00000001
#define FILE_READ_ONLY_DEVICE           0x00000002
#define FILE_FLOPPY_DISKETTE            0x00000004
#define FILE_WRITE_ONCE_MEDIA           0x00000008
#define FILE_REMOTE_DEVICE              0x00000010
#define FILE_DEVICE_IS_MOUNTED          0x00000020
#define FILE_VIRTUAL_VOLUME             0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME  0x00000080
#define FILE_DEVICE_SECURE_OPEN         0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE  0x00000800

//#include "C:\WINDDK\3790.1830\inc\ddk\wdm\wnet\wdm.h"
typedef enum _DEVICE_INSTALL_STATE {
    InstallStateInstalled,
    InstallStateNeedsReinstall,
    InstallStateFailedInstall,
    InstallStateFinishInstall
} DEVICE_INSTALL_STATE, *PDEVICE_INSTALL_STATE;

//these macros 32 bit values only due to %lX
#define MAKE_SWITCH_VAL(Name, Val) case Name: Str = Val; break;
#define MAKE_SWITCH(Name) MAKE_SWITCH_VAL(Name, _T(#Name))
#define MAKE_SWITCH_UNK(Val) default:\
			Str.Format(_T("Unknown: 0x%lX"), Val);\
			break;

#define BIT_STRING_VAL(Val, Mask, ValStr) if (Val & Mask) {\
		if (!Str.IsEmpty()) Str += _T(", ");\
		Str += ValStr;\
	}\
	AllMask |= Mask;
#define BIT_STRING(Val, Mask) BIT_STRING_VAL(Val, Mask, _T(#Mask))
#define BIT_STRING_UNK(Val) if (Val & ~AllMask) {\
		if (!Str.IsEmpty()) Str += _T(", ");\
		Str.AppendFormat(_T("Unknown: 0x%lX"), Val & ~AllMask);\
	}

template <class T>
int compare_right(const T* szFirst, const T* szSecond)
{
	int iBias = 0; //comparison value assuming equal magnitudes
	//determine magnitude of numbers whichever is longer is greater
	for (;; szFirst++, szSecond++) {
		if (!isdigit(*szFirst) && !isdigit(*szSecond)) {
			return iBias;
		} else if (!isdigit(*szFirst)) {
			return -1;
		} else if (!isdigit(*szSecond)) {
			return 1;
		} else if (*szFirst < *szSecond) {
			if (!iBias) iBias = -1;
		} else if (*szFirst > *szSecond) {
			if (!iBias) iBias = 1;
		} else if (!*szFirst && !*szSecond) {
			return iBias;
		}
	}
}

template <class T>
int compare_left(const T* szFirst, const T* szSecond)
{
	//compare two left aligned numbers until different values reached
	for (;; szFirst++, szSecond++) {
		if (!isdigit(*szFirst) && !isdigit(*szSecond)) {
			return 0;
		} else if (!isdigit(*szFirst)) {
			return -1;
		} else if (!isdigit(*szSecond)) {
			return 1;
		} else if (*szFirst < *szSecond) {
			return -1;
		} else if (*szFirst > *szSecond) {
			return 1;
		}
	}	  
}
template <class T>
int strnatcmpbase(	const T* szFirst, const T* szSecond,
							BOOL bCaseInsensitive)
{
	BOOL bTrue = TRUE;
	int iFirst;
	int iSecond;
	T cFirst;
	T cSecond;
	int iFractional;
	int iResult = 0;
	ASSERT(szFirst && szSecond);
	iFirst = iSecond = 0;
	while (bTrue) {
		cFirst = szFirst[iFirst];
		cSecond = szSecond[iSecond];
		// skip over leading spaces or zeros
		while ((unsigned)(cFirst + 1) <= 256 && isspace(cFirst)) cFirst = szFirst[++iFirst];
		while ((unsigned)(cSecond + 1) <= 256 && isspace(cSecond)) cSecond = szSecond[++iSecond];
		if ((unsigned)(cFirst + 1) <= 256 && (unsigned)(cSecond + 1) <= 256 &&
			isdigit(cFirst) && isdigit(cSecond)) {
			iFractional = (cFirst == '0' || cSecond == '0');
			if (iFractional) {
				if ((iResult = compare_left<T>(	szFirst + iFirst,
												szSecond + iSecond)) != 0) {
					break;
				}
			} else {
				if ((iResult = compare_right<T>(szFirst + iFirst,
												szSecond + iSecond)) != 0) {
					break;
				}
			}
		}
		if (!cFirst && !cSecond) {
			//strings are equal, could improve to instead return strcmp result
			iResult = 0;
			break;
		}
		if (bCaseInsensitive) {
			cFirst = (T)toupper(cFirst);
			cSecond = (T)toupper(cSecond);
		}
		if (cFirst < cSecond) {
			iResult = -1;
			break;
		} else if (cFirst > cSecond) {
			iResult = 1;
			break;
		}
		++iFirst;
		++iSecond;
	}
	return iResult;
}

//natural order string comparison
template <class T>
int natcmp(const T* szFirst, const T* szSecond)
{
	return strnatcmpbase<T>(szFirst, szSecond, FALSE);
}

//natural order string comparison with case insensitivity
template <class T>
int naticmp(const T* szFirst, const T* szSecond)
{
	return strnatcmpbase<T>(szFirst, szSecond, TRUE);
}

int CompareDisplayType(DWORD dwType, void* pbEntry1, void* lParam1, void* pbEntry2, void* lParam2)
{
	int iRet = 0;
	int iCount;
	size_t sCount1;
	size_t sCount2;
	size_t sLen1;
	size_t sLen2;
	CTime LogonTime;
	if (dwType != DISPLAY_INDEX) {
		if (!pbEntry1 || !pbEntry2) {
			if (!pbEntry1 && !pbEntry2) return 0;
			return !pbEntry1 ? -1 : 1;
		}
	}
	switch (dwType) {
	case DISPLAY_NONE:
		break;
	case DISPLAY_INDEX:
		if (lParam1 == lParam2) {
			iRet = 0;
		} else {
			iRet = (lParam1 > lParam2) ? 1 : -1;
		}
		break;
	case DISPLAY_UI1:
		if (*(BYTE*)pbEntry1 == *(BYTE*)pbEntry2) {
			iRet = 0;
		} else {
			iRet = (*(BYTE*)pbEntry1 > *(BYTE*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_UI3:
		if (*((BYTE*)pbEntry1 + 2) == *((BYTE*)pbEntry2 + 2)) {
			if (*((BYTE*)pbEntry1 + 1) == *((BYTE*)pbEntry2 + 1)) {
				if (*(BYTE*)pbEntry1 == *(BYTE*)pbEntry2) {
					iRet = 0;
				} else {
					iRet = (*(BYTE*)pbEntry1 > *(BYTE*)pbEntry2) ? 1 : -1;
				}
			} else {
				iRet = (*((BYTE*)pbEntry1 + 1) > *((BYTE*)pbEntry2 + 1)) ? 1 : -1;
			}
		} else {
			iRet = (*((BYTE*)pbEntry1 + 2) > *((BYTE*)pbEntry2 + 2)) ? 1 : -1;
		}
		break;
	case DISPLAY_UI2:
		if (*(WORD*)pbEntry1 == *(WORD*)pbEntry2) {
			iRet = 0;
		} else {
			iRet = (*(WORD*)pbEntry1 > *(WORD*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_UI4:
	case DISPLAY_UI4_WITHEMPTY:
	case DISPLAY_SERVICESTARTUPTYPE:
#ifndef WIN64
	case DISPLAY_UIPTRRESOLUTION:
#endif
		if (!pbEntry1 || !pbEntry2) {
			if (!pbEntry1 && !pbEntry2) return 0;
			return !pbEntry1 ? -1 : 1;
		}
		if (*(DWORD*)pbEntry1 == *(DWORD*)pbEntry2) {
			iRet = 0;
		} else if (dwType == DISPLAY_UI4_WITHEMPTY) {
			if (*(DWORD*)pbEntry1 == -1) iRet = -1;
			if (*(DWORD*)pbEntry2 == -1) iRet = 1;
		} else {
			iRet =	(*(DWORD*)pbEntry1 > *(DWORD*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_UI8:
#ifdef WIN64
	case DISPLAY_UIPTRRESOLUTION:
#endif
		if (*(QWORD*)pbEntry1 == *(QWORD*)pbEntry2) {
			iRet = 0;
		} else {
			iRet =	(*(QWORD*)pbEntry1 > *(QWORD*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_TSTR:
		iRet = _tcsnatcmp((TCHAR*)pbEntry1, (TCHAR*)pbEntry2);
		break;
	case DISPLAY_LPTSTR:
		if (*(TCHAR**)pbEntry1 && *(TCHAR**)pbEntry2) {
			iRet = _tcsnatcmp(*(TCHAR**)pbEntry1, *(TCHAR**)pbEntry2);
		} else if (*(TCHAR**)pbEntry1) {
			iRet = 1;
		} else if (*(TCHAR**)pbEntry2) {
			iRet = -1;
		} else {
			iRet = 0;
		}
		break;
	case DISPLAY_LPTSTRS:
		sCount1 = 0;
		sCount2 = 0;
		iRet = 0;
		while (	sLen1 = _tcslen(*(TCHAR**)pbEntry1 + sCount1),
				sLen2 = _tcslen(*(TCHAR**)pbEntry2 + sCount2),
				sLen1 && sLen2) {
			iRet = _tcsinatcmp(*(TCHAR**)pbEntry1, *(TCHAR**)pbEntry2);
			if (iRet != 0) break;
			sCount1 += sLen1 + 1;
			sCount2 += sLen2 + 1;
		}
		if (iRet == 0 && sLen1 != sLen2) {
			iRet = (sLen1 > sLen2) ? 1 : -1;
		}
		break;
	case DISPLAY_LPATSTRS:
		for (	iRet = 0, iCount = 0;
				iCount < min(	((CStringArray*)pbEntry1)->GetCount(),
								((CStringArray*)pbEntry2)->GetCount());
				iCount++) {
			iRet = _tcsinatcmp(	(*(CStringArray*)pbEntry1)[iCount],
								(*(CStringArray*)pbEntry2)[iCount]);
			if (iRet != 0) break;
		}
		if (iRet == 0 &&	((CStringArray*)pbEntry1)->GetCount() !=
							((CStringArray*)pbEntry2)->GetCount()) {
			iRet = (((CStringArray*)pbEntry1)->GetCount() >
					((CStringArray*)pbEntry2)->GetCount()) ? 1 : -1;
		}
		break;
	case DISPLAY_LPAKEYTSTRS:
		for (	iRet = 0, iCount = 0;
				iCount < min(	((CCopyKVArray*)pbEntry1)->GetCount(),
								((CCopyKVArray*)pbEntry2)->GetCount());
				iCount++) {
			iRet = _tcsinatcmp(	(*(CCopyKVArray*)pbEntry1)[iCount].Key,
								(*(CCopyKVArray*)pbEntry2)[iCount].Key);
			if (iRet != 0) break;
		}
		if (iRet == 0 &&	((CCopyKVArray*)pbEntry1)->GetCount() !=
							((CCopyKVArray*)pbEntry2)->GetCount()) {
			iRet = (((CCopyKVArray*)pbEntry1)->GetCount() >
					((CCopyKVArray*)pbEntry2)->GetCount()) ? 1 : -1;
		}
		break;
	case DISPLAY_LPAKEYVALUES:
	case DISPLAY_LPAHEXKEYVALUES:
		for (	iRet = 0, iCount = 0;
				iCount < min(	((CCopyKVArray*)pbEntry1)->GetCount(),
								((CCopyKVArray*)pbEntry2)->GetCount());
				iCount++) {
			iRet = _tcsinatcmp(	(*(CCopyKVArray*)pbEntry1)[iCount].Key,
								(*(CCopyKVArray*)pbEntry2)[iCount].Key);
			if (iRet != 0) break;
		}
		if (iRet == 0 &&	((CCopyKVArray*)pbEntry1)->GetCount() !=
							((CCopyKVArray*)pbEntry2)->GetCount()) {
			iRet = (((CCopyKVArray*)pbEntry1)->GetCount() >
					((CCopyKVArray*)pbEntry2)->GetCount()) ? 1 : -1;
		}
		if (iRet == 0) iRet = memcmp(	(*(CCopyKVArray*)pbEntry1)[iCount - 1].Value.GetData(),
										(*(CCopyKVArray*)pbEntry2)[iCount - 1].Value.GetData(),
										min((*(CCopyKVArray*)pbEntry1).GetCount(),
											(*(CCopyKVArray*)pbEntry2).GetCount()));
		break;
	case DISPLAY_LPWSTR:
		if (*(WCHAR**)pbEntry1 && *(WCHAR**)pbEntry2) {
			iRet = _wcsinatcmp(*(WCHAR**)pbEntry1, *(WCHAR**)pbEntry2);
		} else if (*(WCHAR**)pbEntry1) {
			iRet = 1;
		} else if (*(WCHAR**)pbEntry2) {
			iRet = -1;
		} else {
			iRet = 0;
		}
		break;
	case DISPLAY_DEPSTATUS:
	case DISPLAY_WINDOWSTATUS:
		if (*(BYTE*)pbEntry1 == *(BYTE*)pbEntry2) {
			iRet = 0;
		} else {
			iRet =	(*(BYTE*)pbEntry1 > *(BYTE*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_SERVICESTATUS:
	case DISPLAY_SERVICETYPE:
	case DISPLAY_DRIVERTYPE:
	case DISPLAY_CONFIGFLAGS:
	case DISPLAY_LDRPFLAGS:
	case DISPLAY_DRVOBJFLAGS:
	case DISPLAY_DEVCAPS:
	case DISPLAY_DEVTYPE:
	case DISPLAY_DEVOBJECTFLAGS:
	case DISPLAY_DEVCHARACTERISTICS:
	case DISPLAY_INSTALLSTATE:
	case DISPLAY_DEVICESTATUS:
	case DISPLAY_DRIVETYPE:
	case DISPLAY_FILESYSTEMFLAGS:
	case DISPLAY_MEDIATYPE:
	case DISPLAY_PARTITIONSTYLE:
	case DISPLAY_DETECTIONTYPE:
		if (*(DWORD*)pbEntry1 == *(DWORD*)pbEntry2) {
			iRet = 0;
		} else {
			iRet =	(*(DWORD*)pbEntry1 > *(DWORD*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_PARTITIONTYPE:
	case DISPLAY_PARTITIONINDICATOR:
		if (*(BYTE*)pbEntry1 == *(BYTE*)pbEntry2) {
			iRet = 0;
		} else {
			iRet =	(*(BYTE*)pbEntry1 > *(BYTE*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_LUID:
		if ((*(LARGE_INTEGER*)pbEntry1).HighPart == 
			(*(LARGE_INTEGER*)pbEntry2).HighPart) {
			if ((*(LARGE_INTEGER*)pbEntry1).LowPart ==
				(*(LARGE_INTEGER*)pbEntry2).LowPart) {
				iRet = 0;
			} else {
				iRet = ((*(LARGE_INTEGER*)pbEntry1).LowPart >
						(*(LARGE_INTEGER*)pbEntry2).LowPart) ? 1 : -1;
			}
		} else {
			iRet = ((*(LARGE_INTEGER*)pbEntry1).HighPart >
					(*(LARGE_INTEGER*)pbEntry2).HighPart) ? 1 : -1;
		}
		break;
	case DISPLAY_GUID:
		if (TRUE) {
			CStringW Str1;
			CStringW Str2;
			StringFromGUID2(*((GUID*)pbEntry1), Str1.GetBuffer((32 + 6 + 1) * sizeof(TCHAR)), (32 + 6 + 1) * sizeof(TCHAR));
			Str1.ReleaseBuffer();
			StringFromGUID2(*((GUID*)pbEntry2), Str2.GetBuffer((32 + 6 + 1) * sizeof(TCHAR)), (32 + 6 + 1) * sizeof(TCHAR));
			Str2.ReleaseBuffer();
			iRet = _wcsnatcmp(Str1, Str2);
		}
		break;
	case DISPLAY_LOGONTYPE:
		if (*(ULONG*)pbEntry1 == *(ULONG*)pbEntry2) {
			iRet = 0;
		} else {
			iRet = ((*(ULONG*)pbEntry1) > (*(ULONG*)pbEntry2)) ? 1 : -1;
		}
		break;
	case DISPLAY_SID:
		if (!*(PSID*)pbEntry1) {
			if (!*(PSID*)pbEntry2) {
				iRet = 0;
			} else {
				iRet = -1;
			}
		} else if (!*(PSID*)pbEntry2) {
			iRet = 1;
		} else {
			iRet = _tcsnatcmp(	CSid((const SID*)(*(PSID*)pbEntry1)).Sid(),
								CSid((const SID*)(*(PSID*)pbEntry2)).Sid());
		}
		break;
	case DISPLAY_FILETIME:
		if (*(ULONGLONG*)pbEntry1 == *(ULONGLONG*)pbEntry2) {
			iRet = 0;
		} else {
			iRet = (*(ULONGLONG*)pbEntry1) > (*(ULONGLONG*)pbEntry2) ? 1 : -1;
		}
		break;
	case DISPLAY_COUNT:
		if ((*(CDWordArray*)pbEntry1).GetCount() ==
			(*(CDWordArray*)pbEntry2).GetCount()) {
			iRet = 0;
		} else {
			iRet = ((*(CDWordArray*)pbEntry1).GetCount() >
					(*(CDWordArray*)pbEntry2).GetCount()) ? 1 : -1;
		}
		break;
	case DISPLAY_DWORDS:
		for (	iCount = 0;
				iCount < min(	(*(CDWordArray*)pbEntry1).GetCount(),
								(*(CDWordArray*)pbEntry2).GetCount());
				iCount++) {
			if ((*(CDWordArray*)pbEntry1)[iCount] ==
				(*(CDWordArray*)pbEntry2)[iCount]) continue;
			iRet = ((*(CDWordArray*)pbEntry1)[iCount] >
					(*(CDWordArray*)pbEntry2)[iCount]) ? 1 : -1;
			break;
		}
		if (iCount == min(	(*(CDWordArray*)pbEntry1).GetCount(),
							(*(CDWordArray*)pbEntry2).GetCount())) {
			if ((*(CDWordArray*)pbEntry1).GetCount() ==
				(*(CDWordArray*)pbEntry2).GetCount()) {
				iRet = 0;
			} else {
				iRet = ((*(CDWordArray*)pbEntry1).GetCount() >
						(*(CDWordArray*)pbEntry2).GetCount()) ? 1 : -1;
			}
		}
		break;
	case DISPLAY_HEXBYTES:
		iRet = memcmp(	(*(CByteArray*)pbEntry1).GetData(), 
						(*(CByteArray*)pbEntry2).GetData(),
						min((*(CByteArray*)pbEntry1).GetCount(),
							(*(CByteArray*)pbEntry2).GetCount()));
		if (iRet == 0 && (*(CByteArray*)pbEntry1).GetCount() !=
							(*(CByteArray*)pbEntry2).GetCount()) {
			iRet =	(	(*(CByteArray*)pbEntry1).GetCount() >
						(*(CByteArray*)pbEntry2).GetCount()) ? 1 : -1;
		}
		break;
	case DISPLAY_CHS:
		if (((CHS*)pbEntry1)->Cylinder == ((CHS*)pbEntry2)->Cylinder) {
			if (((CHS*)pbEntry1)->Head == ((CHS*)pbEntry2)->Head) {
				if (((CHS*)pbEntry1)->Sector == ((CHS*)pbEntry2)->Sector) {
					iRet = 0;
				} else
					iRet = ((CHS*)pbEntry1)->Sector > ((CHS*)pbEntry2)->Sector;
			} else
				iRet = ((CHS*)pbEntry1)->Head > ((CHS*)pbEntry2)->Head ? 1 : -1;
		} else 
			iRet = CYLINDER_VALUE(((CHS*)pbEntry1)->Cylinder) > CYLINDER_VALUE(((CHS*)pbEntry2)->Cylinder) ? 1 : -1;
		break;
	default:
		iRet = 0;
		break;
	}
	return iRet;
}

void StringFromHex(LPCTSTR HexBytes, CString & Str)
{
	TCHAR cVal;
	DWORD dwCount;
	for (dwCount = 0; HexBytes[dwCount]; dwCount += 2) {
		cVal = 0;
		if (HexBytes[dwCount] >= '0' && HexBytes[dwCount] <= '9') {
			cVal = (HexBytes[dwCount] - '0') << 4;
		} else if (HexBytes[dwCount] >= 'A' && HexBytes[dwCount] <= 'F') {
			cVal = (HexBytes[dwCount] - 'A' + 10) << 4;
		} else if (HexBytes[dwCount] >= 'a' && HexBytes[dwCount] <= 'f') {
			cVal = (HexBytes[dwCount] - 'a' + 10) << 4;
		}
		if (HexBytes[dwCount + 1]) {
			if (HexBytes[dwCount + 1] >= '0' && HexBytes[dwCount + 1] <= '9') {
				cVal += (HexBytes[dwCount + 1] - '0');
			} else if (HexBytes[dwCount + 1] >= 'A' && HexBytes[dwCount + 1] <= 'F') {
				cVal += (HexBytes[dwCount + 1] - 'A' + 10);
			} else if (HexBytes[dwCount + 1] >= 'a' && HexBytes[dwCount + 1] <= 'f') {
				cVal += (HexBytes[dwCount + 1] - 'a' + 10);
			}
		}
		Str += cVal;
	}
}

void GetKVValueString(KeyValue* pKV, CString & Str, BOOL bHexStrings = FALSE)
{
	int iCount;
	switch (pKV->dwType) {
	case REG_DWORD:
		Str.AppendFormat(_T("dword:%08X"), *(DWORD*)pKV->Value.GetData());
		break;
	case REG_SZ:
		Str += _T("\"");
		Str += (LPCTSTR)pKV->Value.GetData(); //should encode C escape sequences
		if (bHexStrings) {
			Str += _T("\"");
			StringFromHex((LPCTSTR)pKV->Value.GetData(), Str);
			Str += _T("\"");
		}
		Str += _T("\"");
		break;
	case REG_EXPAND_SZ:
	case REG_MULTI_SZ:
	case REG_BINARY:
	case REG_NONE:
	default:
		Str.AppendFormat(_T("hex(%lu):"), pKV->dwType);
		for (	iCount = 0; iCount < pKV->Value.GetCount();
				iCount++) {
			Str.AppendFormat((iCount == pKV->Value.GetCount() - 1) ? _T("%02X") : _T("%02X,"), pKV->Value.GetAt(iCount));
		}
		break;
	}
}

void GetDisplayString(DWORD dwType, void* pbEntry, void* lParam, CString & Str)
{
	int iCount;
	size_t sCount;
	size_t sLen;
	ULONGLONG AllMask = 0;
	CTime LogonTime;
	Str.Empty();
	if (dwType != DISPLAY_INDEX && !pbEntry) return;
	switch (dwType) {
	case DISPLAY_INDEX:
		Str.Format(_T("%lu"), lParam);
		break;
	case DISPLAY_UI1:
		Str.Format(_T("0x%X"), *(BYTE*)pbEntry);
		break;
	case DISPLAY_UI3:
		Str.Format(_T("0x%lX"), *(BYTE*)pbEntry | *((BYTE*)pbEntry + 1) << 8 | *((BYTE*)pbEntry + 2) << 16);
		break;
	case DISPLAY_UI2:
		Str.Format(_T("0x%hX"), *(WORD*)pbEntry);
		break;
	case DISPLAY_UI4:
		Str.Format(_T("0x%lX"), *(DWORD*)pbEntry);
		break;
	case DISPLAY_UI8:
		Str.Format(_T("0x%llX"), *(QWORD*)pbEntry);
		break;
	case DISPLAY_UI4_WITHEMPTY:
		if (*(DWORD*)pbEntry != -1) {
			Str.Format(_T("0x%lX"), *(DWORD*)pbEntry);
		}
		break;
	case DISPLAY_UIPTRRESOLUTION:
		if (((AddressResolutionTable*)pbEntry)->szBaseName != NULL) {
#ifdef WIN64
			Str.Format(_T("%s+0x%llX"),
						((AddressResolutionTable*)pbEntry)->szBaseName,
						(ULONG_PTR)((AddressResolutionTable*)pbEntry)->pvAddress -
						(ULONG_PTR)((AddressResolutionTable*)pbEntry)->pvDLLBase);
#else
			Str.Format(_T("%s+0x%lX"),
						((AddressResolutionTable*)pbEntry)->szBaseName,
						(ULONG_PTR)((AddressResolutionTable*)pbEntry)->pvAddress -
						(ULONG_PTR)((AddressResolutionTable*)pbEntry)->pvDLLBase);
#endif
		} else {
#ifdef WIN64
			Str.Format(_T("%llX"),
						((AddressResolutionTable*)pbEntry)->pvAddress);
#else
			Str.Format(_T("%lX"),
						((AddressResolutionTable*)pbEntry)->pvAddress);
#endif
		}
		break;
	case DISPLAY_TSTR:
		Str = (TCHAR*)pbEntry;
		break;
	case DISPLAY_LPTSTR:
		Str = *(TCHAR**)pbEntry;
		break;
	case DISPLAY_LPTSTRS:
		sCount = 0;
		while ((sLen = _tcslen(*(TCHAR**)pbEntry + sCount)) != 0) {
			Str += (*(TCHAR**)pbEntry + sCount);
			sCount += sLen + 1;
			if (*(*(TCHAR**)pbEntry + sCount)) Str += ", ";
		}
		break;
	case DISPLAY_LPATSTRS:
		for (	iCount = 0; iCount < ((CStringArray*)pbEntry)->GetCount();
				iCount++) {
			Str += (*(CStringArray*)pbEntry)[iCount];
			if (iCount != ((CStringArray*)pbEntry)->GetCount() - 1) Str += ", ";
		}
		break;
	case DISPLAY_LPAKEYTSTRS:
		for (	iCount = 0; iCount < ((CCopyKVArray*)pbEntry)->GetCount();
				iCount++) {
			Str += (*(CCopyKVArray*)pbEntry)[iCount].Key;
			if (iCount != ((CCopyKVArray*)pbEntry)->GetCount() - 1) Str += ", ";
		}
		break;
	case DISPLAY_LPAKEYVALUES:
		for (	iCount = 0; iCount < ((CCopyKVArray*)pbEntry)->GetCount();
				iCount++) {
			Str += _T("[");
			Str += (*(CCopyKVArray*)pbEntry)[iCount].Key;
			Str += _T(" => ");
			GetKVValueString(((CCopyKVArray*)pbEntry)->GetData() + iCount, Str);
			if (iCount != ((CCopyKVArray*)pbEntry)->GetCount() - 1) Str += "], ";
			else Str += _T("]");
		}
		break;
	case DISPLAY_LPAHEXKEYVALUES:
		for (	iCount = 0; iCount < ((CCopyKVArray*)pbEntry)->GetCount();
				iCount++) {
			Str += _T("[");
			Str += (*(CCopyKVArray*)pbEntry)[iCount].Key;
			Str += _T("(");
			StringFromHex((*(CCopyKVArray*)pbEntry)[iCount].Key, Str);
			Str += _T(") => ");
			GetKVValueString(((CCopyKVArray*)pbEntry)->GetData() + iCount, Str, TRUE);
			if (iCount != ((CCopyKVArray*)pbEntry)->GetCount() - 1) Str += "], ";
			else Str += _T("]");
		}
		break;
	case DISPLAY_LPWSTR:
		Str = *(WCHAR**)pbEntry;
		break;
	case DISPLAY_DEPSTATUS:
		if (*(BYTE*)pbEntry == 0xFF) {
			Str = "<Unknown>";
		} else if (	*(BYTE*)pbEntry &
					(MEM_EXECUTE_OPTION_DISABLE |
						MEM_EXECUTE_OPTION_ENABLE)) {
			Str = "Off";
		} else {
			Str = "On";
		}
		break;
	case DISPLAY_WINDOWSTATUS:
		if (*(BYTE*)pbEntry == 1) {
			Str = "Running";
		} else if (*(BYTE*)pbEntry == 0) {
			Str = "Not Responding";
		}
		break;
	case DISPLAY_SERVICESTATUS:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH_VAL(SERVICE_STOPPED, _T("Stopped"))
		MAKE_SWITCH_VAL(SERVICE_START_PENDING, _T("Start Pending"))
		MAKE_SWITCH_VAL(SERVICE_STOP_PENDING, _T("Stop Pending"))
		MAKE_SWITCH_VAL(SERVICE_RUNNING, _T("Running"))
		MAKE_SWITCH_VAL(SERVICE_CONTINUE_PENDING, _T("Continue Pending"))
		MAKE_SWITCH_VAL(SERVICE_PAUSE_PENDING, _T("Pause Pending"))
		MAKE_SWITCH_VAL(SERVICE_PAUSED, _T("Paused"))
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_SERVICETYPE:
		BIT_STRING_VAL(*(DWORD*)pbEntry, SERVICE_INTERACTIVE_PROCESS, _T("Interactive"))
		BIT_STRING_VAL(*(DWORD*)pbEntry, SERVICE_WIN32_OWN_PROCESS, _T("Own Process"))
		BIT_STRING_VAL(*(DWORD*)pbEntry, SERVICE_WIN32_SHARE_PROCESS, _T("Share Process"))
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_DRIVERTYPE:
		BIT_STRING_VAL(*(DWORD*)pbEntry, SERVICE_KERNEL_DRIVER, _T("Kernel"))
		BIT_STRING_VAL(*(DWORD*)pbEntry, SERVICE_FILE_SYSTEM_DRIVER, _T("File System"))
		BIT_STRING_VAL(*(DWORD*)pbEntry, SERVICE_ADAPTER, _T("Adapter"))
		BIT_STRING_VAL(*(DWORD*)pbEntry, SERVICE_RECOGNIZER_DRIVER, _T("Recognizer"))
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_SERVICESTARTUPTYPE:
		switch (*(ULONG*)pbEntry) {
		MAKE_SWITCH_VAL(SERVICE_BOOT_START, _T("Boot"))
		MAKE_SWITCH_VAL(SERVICE_SYSTEM_START, _T("System"))
		MAKE_SWITCH_VAL(SERVICE_AUTO_START, _T("Automatic"))
		MAKE_SWITCH_VAL(SERVICE_DEMAND_START, _T("Demand"))
		MAKE_SWITCH_VAL(SERVICE_DISABLED, _T("Disabled"))
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_LUID:
		Str.Format(	_T("0x%lX:0x%lX"),
					((LUID*)pbEntry)->HighPart, ((LUID*)pbEntry)->LowPart);
		break;
	case DISPLAY_GUID:
		{
			CStringW StrW;
			StringFromGUID2(*((GUID*)pbEntry), StrW.GetBuffer((32 + 6 + 1) * sizeof(TCHAR)), (32 + 6 + 1) * sizeof(TCHAR));
			StrW.ReleaseBuffer();
			Str = StrW;
		}
		break;
	case DISPLAY_LOGONTYPE:
		switch (*(ULONG*)pbEntry) {
		MAKE_SWITCH(UndefinedLogonType)
		MAKE_SWITCH(Interactive)
		MAKE_SWITCH(Network)
		MAKE_SWITCH(Batch)
		MAKE_SWITCH(Service)
		MAKE_SWITCH(Proxy)
		MAKE_SWITCH(Unlock)
		MAKE_SWITCH_VAL(NetworkCleartext, _T("Network Cleartext"))
		MAKE_SWITCH_VAL(NewCredentials, _T("New Credentials"))
		MAKE_SWITCH_VAL(RemoteInteractive, _T("Remote Interactive"))
		MAKE_SWITCH_VAL(CachedInteractive, _T("Cached Interactive"))
		MAKE_SWITCH_VAL(CachedRemoteInteractive, _T("Cached Remote Interactive"))
		MAKE_SWITCH_VAL(CachedUnlock, _T("Cached Unlock"))
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_SID:
		if (*(PSID*)pbEntry) {
			Str = (CSid((const SID*)*(PSID*)pbEntry)).Sid();
		}
		break;
	case DISPLAY_FILETIME:
		LogonTime = *(FILETIME*)pbEntry;
		Str = LogonTime.Format(_T("%c"));
		//Str = LogonTime.Format("%A, %B %d, %Y %I:%M:%S%p  %Z");
		//Str.Format("%I64u",
		//			 m_LogonSessionInformation[pDispInfo->item.lParam].
		//					LogonTime.QuadPart);
		break;
	case DISPLAY_COUNT:
		Str.Format(((*(CByteArray*)pbEntry).GetCount() % 4) ? _T("%i with additional partial") : _T("%i"), (*(CByteArray*)pbEntry).GetCount() / 4);
		break;
	case DISPLAY_DWORDS:
		for (	iCount = 0; iCount < (*(CByteArray*)pbEntry).GetCount() / 4;
				iCount++) {
			Str.AppendFormat(	iCount == 0 ? _T("%i") : _T(", %i"),
								((DWORD*)(*(CByteArray*)pbEntry).GetData())[iCount]);
		}
		//display last partial 1, 2 or 3 bytes
		break;
	case DISPLAY_HEXBYTES:
		for (	iCount = 0; iCount < (*(CByteArray*)pbEntry).GetCount();
				iCount++) {
			Str.AppendFormat(iCount == (*(CByteArray*)pbEntry).GetCount() - 1 ? _T("%02X") : _T("%02X "), (*(CByteArray*)pbEntry)[iCount]);
		}
		break;
	case DISPLAY_CONFIGFLAGS:
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_DISABLED)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_REMOVED)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_MANUAL_INSTALL)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_IGNORE_BOOT_LC)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_NET_BOOT)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_REINSTALL)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_FAILEDINSTALL)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_CANTSTOPACHILD)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_OKREMOVEROM)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_NOREMOVEEXIT)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_FINISH_INSTALL)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_NEEDS_FORCED_CONFIG)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_NETBOOT_CARD)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_PARTIAL_LOG_CONF)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_SUPPRESS_SURPRISE)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_VERIFY_HARDWARE)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_FINISHINSTALL_UI)
		BIT_STRING(*(DWORD*)pbEntry, CONFIGFLAG_FINISHINSTALL_ACTION)
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_LDRPFLAGS:
		BIT_STRING(*(DWORD*)pbEntry, LDRP_STATIC_LINK)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_IMAGE_DLL)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_LOAD_IN_PROGRESS)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_UNLOAD_IN_PROGRESS)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_ENTRY_PROCESSED)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_ENTRY_INSERTED)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_CURRENT_LOAD)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_FAILED_BUILTIN_LOAD)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_DONT_CALL_FOR_THREADS)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_PROCESS_ATTACH_CALLED)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_DEBUG_SYMBOLS_LOADED)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_IMAGE_NOT_AT_BASE)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_COR_IMAGE)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_COR_OWNS_UNMAP)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_SYSTEM_MAPPED)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_IMAGE_VERIFYING)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_DRIVER_DEPENDENT_DLL)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_ENTRY_NATIVE)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_REDIRECTED)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_NON_PAGED_DEBUG_INFO)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_MM_LOADED)
		BIT_STRING(*(DWORD*)pbEntry, LDRP_COMPAT_DATABASE_PROCESSED)
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_DRVOBJFLAGS:
		BIT_STRING(*(DWORD*)pbEntry, DRVO_UNLOAD_INVOKED)
		BIT_STRING(*(DWORD*)pbEntry, DRVO_LEGACY_DRIVER)
		BIT_STRING(*(DWORD*)pbEntry, DRVO_BUILTIN_DRIVER)
		BIT_STRING(*(DWORD*)pbEntry, DRVO_REINIT_REGISTERED)
		BIT_STRING(*(DWORD*)pbEntry, DRVO_INITIALIZED)
		BIT_STRING(*(DWORD*)pbEntry, DRVO_BOOTREINIT_REGISTERED)
		BIT_STRING(*(DWORD*)pbEntry, DRVO_LEGACY_RESOURCES)
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_DEVTYPE:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH(FILE_DEVICE_BEEP)
		MAKE_SWITCH(FILE_DEVICE_CD_ROM)
		MAKE_SWITCH(FILE_DEVICE_CD_ROM_FILE_SYSTEM)
		MAKE_SWITCH(FILE_DEVICE_CONTROLLER)
		MAKE_SWITCH(FILE_DEVICE_DATALINK)
		MAKE_SWITCH(FILE_DEVICE_DFS)
		MAKE_SWITCH(FILE_DEVICE_DISK)
		MAKE_SWITCH(FILE_DEVICE_DISK_FILE_SYSTEM)
		MAKE_SWITCH(FILE_DEVICE_FILE_SYSTEM)
		MAKE_SWITCH(FILE_DEVICE_INPORT_PORT)
		MAKE_SWITCH(FILE_DEVICE_KEYBOARD)
		MAKE_SWITCH(FILE_DEVICE_MAILSLOT)
		MAKE_SWITCH(FILE_DEVICE_MIDI_IN)
		MAKE_SWITCH(FILE_DEVICE_MIDI_OUT)
		MAKE_SWITCH(FILE_DEVICE_MOUSE)
		MAKE_SWITCH(FILE_DEVICE_MULTI_UNC_PROVIDER)
		MAKE_SWITCH(FILE_DEVICE_NAMED_PIPE)
		MAKE_SWITCH(FILE_DEVICE_NETWORK)
		MAKE_SWITCH(FILE_DEVICE_NETWORK_BROWSER)
		MAKE_SWITCH(FILE_DEVICE_NETWORK_FILE_SYSTEM)
		MAKE_SWITCH(FILE_DEVICE_NULL)
		MAKE_SWITCH(FILE_DEVICE_PARALLEL_PORT)
		MAKE_SWITCH(FILE_DEVICE_PHYSICAL_NETCARD)
		MAKE_SWITCH(FILE_DEVICE_PRINTER)
		MAKE_SWITCH(FILE_DEVICE_SCANNER)
		MAKE_SWITCH(FILE_DEVICE_SERIAL_MOUSE_PORT)
		MAKE_SWITCH(FILE_DEVICE_SERIAL_PORT)
		MAKE_SWITCH(FILE_DEVICE_SCREEN)
		MAKE_SWITCH(FILE_DEVICE_SOUND)
		MAKE_SWITCH(FILE_DEVICE_STREAMS)
		MAKE_SWITCH(FILE_DEVICE_TAPE)
		MAKE_SWITCH(FILE_DEVICE_TAPE_FILE_SYSTEM)
		MAKE_SWITCH(FILE_DEVICE_TRANSPORT)
		MAKE_SWITCH(FILE_DEVICE_UNKNOWN)
		MAKE_SWITCH(FILE_DEVICE_VIDEO)
		MAKE_SWITCH(FILE_DEVICE_VIRTUAL_DISK)
		MAKE_SWITCH(FILE_DEVICE_WAVE_IN)
		MAKE_SWITCH(FILE_DEVICE_WAVE_OUT)
		MAKE_SWITCH(FILE_DEVICE_8042_PORT)
		MAKE_SWITCH(FILE_DEVICE_NETWORK_REDIRECTOR)
		MAKE_SWITCH(FILE_DEVICE_BATTERY)
		MAKE_SWITCH(FILE_DEVICE_BUS_EXTENDER)
		MAKE_SWITCH(FILE_DEVICE_MODEM)
		MAKE_SWITCH(FILE_DEVICE_VDM)
		MAKE_SWITCH(FILE_DEVICE_MASS_STORAGE)
		MAKE_SWITCH(FILE_DEVICE_SMB)
		MAKE_SWITCH(FILE_DEVICE_KS)
		MAKE_SWITCH(FILE_DEVICE_CHANGER)
		MAKE_SWITCH(FILE_DEVICE_SMARTCARD)
		MAKE_SWITCH(FILE_DEVICE_ACPI)
		MAKE_SWITCH(FILE_DEVICE_DVD)
		MAKE_SWITCH(FILE_DEVICE_FULLSCREEN_VIDEO)
		MAKE_SWITCH(FILE_DEVICE_DFS_FILE_SYSTEM)
		MAKE_SWITCH(FILE_DEVICE_DFS_VOLUME)
		MAKE_SWITCH(FILE_DEVICE_SERENUM)
		MAKE_SWITCH(FILE_DEVICE_TERMSRV)
		MAKE_SWITCH(FILE_DEVICE_KSEC)
		MAKE_SWITCH(FILE_DEVICE_FIPS)
		MAKE_SWITCH(FILE_DEVICE_INFINIBAND)
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_DEVCAPS:
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_LOCKSUPPORTED)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_EJECTSUPPORTED)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_REMOVABLE)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_DOCKDEVICE)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_UNIQUEID)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_SILENTINSTALL)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_RAWDEVICEOK)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_SURPRISEREMOVALOK)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_HARDWAREDISABLED)
		BIT_STRING(*(DWORD*)pbEntry, CM_DEVCAP_NONDYNAMIC)
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_DEVOBJECTFLAGS:
		BIT_STRING(*(DWORD*)pbEntry, DO_VERIFY_VOLUME)
		BIT_STRING(*(DWORD*)pbEntry, DO_BUFFERED_IO)
		BIT_STRING(*(DWORD*)pbEntry, DO_EXCLUSIVE)
		BIT_STRING(*(DWORD*)pbEntry, DO_DIRECT_IO)
		BIT_STRING(*(DWORD*)pbEntry, DO_MAP_IO_BUFFER)
		BIT_STRING(*(DWORD*)pbEntry, DO_DEVICE_HAS_NAME)
		BIT_STRING(*(DWORD*)pbEntry, DO_DEVICE_INITIALIZING)
		BIT_STRING(*(DWORD*)pbEntry, DO_SYSTEM_BOOT_PARTITION)
		BIT_STRING(*(DWORD*)pbEntry, DO_LONG_TERM_REQUESTS)
		BIT_STRING(*(DWORD*)pbEntry, DO_NEVER_LAST_DEVICE)
		BIT_STRING(*(DWORD*)pbEntry, DO_SHUTDOWN_REGISTERED)
		BIT_STRING(*(DWORD*)pbEntry, DO_BUS_ENUMERATED_DEVICE)
		BIT_STRING(*(DWORD*)pbEntry, DO_POWER_PAGABLE)
		BIT_STRING(*(DWORD*)pbEntry, DO_POWER_INRUSH)
		BIT_STRING(*(DWORD*)pbEntry, DO_LOW_PRIORITY_FILESYSTEM)
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_DEVCHARACTERISTICS:
		BIT_STRING(*(DWORD*)pbEntry, FILE_REMOVABLE_MEDIA)
		BIT_STRING(*(DWORD*)pbEntry, FILE_READ_ONLY_DEVICE)
		BIT_STRING(*(DWORD*)pbEntry, FILE_FLOPPY_DISKETTE)
		BIT_STRING(*(DWORD*)pbEntry, FILE_WRITE_ONCE_MEDIA)
		BIT_STRING(*(DWORD*)pbEntry, FILE_REMOTE_DEVICE)
		BIT_STRING(*(DWORD*)pbEntry, FILE_DEVICE_IS_MOUNTED)
		BIT_STRING(*(DWORD*)pbEntry, FILE_VIRTUAL_VOLUME)
		BIT_STRING(*(DWORD*)pbEntry, FILE_AUTOGENERATED_DEVICE_NAME)
		BIT_STRING(*(DWORD*)pbEntry, FILE_DEVICE_SECURE_OPEN)
		BIT_STRING(*(DWORD*)pbEntry, FILE_CHARACTERISTIC_PNP_DEVICE)
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_INSTALLSTATE:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH(InstallStateInstalled)
		MAKE_SWITCH(InstallStateNeedsReinstall)
		MAKE_SWITCH(InstallStateFailedInstall)
		MAKE_SWITCH(InstallStateFinishInstall)
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_DEVICESTATUS:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH(CR_NO_SUCH_DEVNODE)
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_DRIVETYPE:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH(DRIVE_UNKNOWN)
		MAKE_SWITCH(DRIVE_NO_ROOT_DIR)
		MAKE_SWITCH(DRIVE_REMOVABLE)
		MAKE_SWITCH(DRIVE_FIXED)
		MAKE_SWITCH(DRIVE_REMOTE)
		MAKE_SWITCH(DRIVE_CDROM)
		MAKE_SWITCH(DRIVE_RAMDISK)
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_FILESYSTEMFLAGS:
		BIT_STRING(*(DWORD*)pbEntry, FILE_CASE_SENSITIVE_SEARCH)
		BIT_STRING(*(DWORD*)pbEntry, FILE_CASE_PRESERVED_NAMES)
		BIT_STRING(*(DWORD*)pbEntry, FILE_UNICODE_ON_DISK)
		BIT_STRING(*(DWORD*)pbEntry, FILE_PERSISTENT_ACLS)
		BIT_STRING(*(DWORD*)pbEntry, FILE_FILE_COMPRESSION)
		BIT_STRING(*(DWORD*)pbEntry, FILE_VOLUME_QUOTAS)
		BIT_STRING(*(DWORD*)pbEntry, FILE_SUPPORTS_SPARSE_FILES)
		BIT_STRING(*(DWORD*)pbEntry, FILE_SUPPORTS_REPARSE_POINTS)
		BIT_STRING(*(DWORD*)pbEntry, FILE_SUPPORTS_REMOTE_STORAGE)
		BIT_STRING(*(DWORD*)pbEntry, FILE_VOLUME_IS_COMPRESSED)
		BIT_STRING(*(DWORD*)pbEntry, FILE_SUPPORTS_OBJECT_IDS)
		BIT_STRING(*(DWORD*)pbEntry, FILE_SUPPORTS_ENCRYPTION)
		BIT_STRING(*(DWORD*)pbEntry, FILE_NAMED_STREAMS)
		BIT_STRING(*(DWORD*)pbEntry, FILE_READ_ONLY_VOLUME)
		BIT_STRING(*(DWORD*)pbEntry, FILE_SEQUENTIAL_WRITE_ONCE)
		BIT_STRING(*(DWORD*)pbEntry, FILE_SUPPORTS_TRANSACTIONS)
		BIT_STRING_UNK(*(DWORD*)pbEntry)
		break;
	case DISPLAY_MEDIATYPE:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH_VAL(DRIVE_UNKNOWN, _T("Format is unknown"))
		MAKE_SWITCH_VAL(F5_1Pt2_512, _T("5.25\", 1.2MB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F3_1Pt44_512, _T("3.5\",  1.44MB, 512 bytes/sector"))
		MAKE_SWITCH_VAL(F3_2Pt88_512, _T("3.5\",  2.88MB, 512 bytes/sector"))
		MAKE_SWITCH_VAL(F3_20Pt8_512, _T("3.5\",  20.8MB, 512 bytes/sector"))
		MAKE_SWITCH_VAL(F3_720_512, _T("3.5\",  720KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F5_360_512, _T("5.25\", 360KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F5_320_512, _T("5.25\", 320KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F5_320_1024, _T("5.25\", 320KB,  1024 bytes/sector"))
		MAKE_SWITCH_VAL(F5_180_512, _T("5.25\", 180KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F5_160_512, _T("5.25\", 160KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(RemovableMedia, _T("Removable media other than floppy"))
		MAKE_SWITCH_VAL(FixedMedia, _T("Fixed hard disk media"))
		MAKE_SWITCH_VAL(F3_120M_512, _T("3.5\", 120M Floppy"))
		MAKE_SWITCH_VAL(F3_640_512, _T("3.5\" ,  640KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F5_640_512, _T("5.25\",  640KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F5_720_512, _T("5.25\",  720KB,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F3_1Pt2_512, _T("3.5\" ,  1.2Mb,  512 bytes/sector"))
		MAKE_SWITCH_VAL(F3_1Pt23_1024, _T("3.5\" ,  1.23Mb, 1024 bytes/sector"))
		MAKE_SWITCH_VAL(F5_1Pt23_1024, _T("5.25\",  1.23MB, 1024 bytes/sector"))
		MAKE_SWITCH_VAL(F3_128Mb_512, _T("3.5\" MO 128Mb   512 bytes/sector"))
		MAKE_SWITCH_VAL(F3_230Mb_512, _T("3.5\" MO 230Mb   512 bytes/sector"))
		MAKE_SWITCH_VAL(F8_256_128, _T("8\",     256KB,  128 bytes/sector"))
		MAKE_SWITCH_VAL(F3_200Mb_512, _T("3.5\",   200M Floppy (HiFD)"))
		MAKE_SWITCH_VAL(F3_240M_512, _T("3.5\",   240Mb Floppy (HiFD)"))
		MAKE_SWITCH_VAL(F3_32M_512, _T("3.5\",   32Mb Floppy"))
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_PARTITIONSTYLE:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH_VAL(PARTITION_STYLE_MBR, _T("MBR"))
		MAKE_SWITCH_VAL(PARTITION_STYLE_GPT, _T("GPT"))
		MAKE_SWITCH_VAL(PARTITION_STYLE_RAW, _T("RAW"))
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_DETECTIONTYPE:
		switch (*(DWORD*)pbEntry) {
		MAKE_SWITCH_VAL(DetectNone, _T("None"))
		MAKE_SWITCH_VAL(DetectInt13, _T("Int13"))
		MAKE_SWITCH_VAL(DetectExInt13, _T("Extended Int13"))
		MAKE_SWITCH_UNK(*(DWORD*)pbEntry)
		}
		break;
	case DISPLAY_CHS:
		Str.Format(_T("%02X %02X %03X"), ((CHS*)pbEntry)->Head, ((CHS*)pbEntry)->Sector, CYLINDER_VALUE(((CHS*)pbEntry)->Cylinder));
		break;
	case DISPLAY_PARTITIONTYPE:
		if ((*(BYTE*)pbEntry & PARTITION_NTFT) && ((*(BYTE*)pbEntry & ~0xC0) == PARTITION_FAT_12)) {
			Str = _T("NTFT FAT12");
		} else if ((*(BYTE*)pbEntry & PARTITION_NTFT) && ((*(BYTE*)pbEntry & ~0xC0) == PARTITION_IFS)) {
			Str = _T("NTFT IFS");
		} else if ((*(BYTE*)pbEntry & PARTITION_NTFT) && ((*(BYTE*)pbEntry & ~0xC0) == PARTITION_HUGE)) {
			Str = _T("NTFT HUGE");
		} else if ((*(BYTE*)pbEntry & PARTITION_NTFT) && ((*(BYTE*)pbEntry & ~0xC0) == PARTITION_FAT32)) {
			Str = _T("NTFT FAT32");
		} else if ((*(BYTE*)pbEntry & PARTITION_NTFT) && ((*(BYTE*)pbEntry & ~0xC0) == PARTITION_FAT32_XINT13)) {
			Str = _T("NTFT FAT32 INT13");
		} else if ((*(BYTE*)pbEntry & PARTITION_NTFT) && ((*(BYTE*)pbEntry & ~0xC0) == PARTITION_XINT13)) {
			Str = _T("NTFT INT13");
		} else if ((*(BYTE*)pbEntry) == PARTITION_FAT_12) {
			Str = _T("FAT12");
		} else if ((*(BYTE*)pbEntry) == PARTITION_FAT_16) {
			Str = _T("FAT16");
		} else if ((*(BYTE*)pbEntry) == PARTITION_IFS) {
			Str = _T("IFS");
		} else if ((*(BYTE*)pbEntry) == PARTITION_HUGE) {
			Str = _T("HUGE");
		} else if ((*(BYTE*)pbEntry) == PARTITION_FAT32) {
			Str = _T("FAT32");
		} else if ((*(BYTE*)pbEntry) == PARTITION_FAT32_XINT13) {
			Str = _T("FAT32 INT13");
		} else if ((*(BYTE*)pbEntry) == PARTITION_XINT13) {
			Str = _T("INT13");
		} else if ((*(BYTE*)pbEntry) == PARTITION_ENTRY_UNUSED) {
			Str = _T("Unused");
		} else if ((*(BYTE*)pbEntry) == PARTITION_XENIX_1) {
			Str = _T("XENIX 1");
		} else if ((*(BYTE*)pbEntry) == PARTITION_XENIX_2) {
			Str = _T("XENIX 2");
		} else if ((*(BYTE*)pbEntry) == PARTITION_EXTENDED) {
			Str = _T("Extended");
		} else if ((*(BYTE*)pbEntry) == PARTITION_OS2BOOTMGR) {
			Str = _T("OS2 Boot Manager");
		} else if ((*(BYTE*)pbEntry) == PARTITION_XINT13_EXTENDED) {
			Str = _T("INT13 Extended");
		} else if ((*(BYTE*)pbEntry) == PARTITION_PREP) {
			Str = _T("PowerPC Reference Platform (PReP)");
		} else if ((*(BYTE*)pbEntry) == PARTITION_LDM) {
			Str = _T("Logical Disk Manager");
		} else if ((*(BYTE*)pbEntry) == PARTITION_UNIX) {
			Str = _T("Unix");
		} else {
			Str.Format(_T("Unknown: %02X"), *(BYTE*)pbEntry);
		}
		break;
	case DISPLAY_PARTITIONINDICATOR:
		if ((*(BYTE*)pbEntry) == 0x80) {
			Str = _T("Active");
		} else if ((*(BYTE*)pbEntry) == 0x00) {
			Str = _T("Inactive");
		} else {
			Str.Format(_T("Unknown: %02X"), *(BYTE*)pbEntry);
		}
		break;
	}
}

#include "MainFrm.h"
#include <afxmt.h>

//need to make a class for thread safety on initialization and shutdown
CString g_TraceString;
CCriticalSection g_TraceCS;

void GetTraceLog(CString& String)
{
	if (g_TraceCS.Lock()) {
		String = g_TraceString;
		g_TraceString.Empty();
		g_TraceCS.Unlock();
	}
}

void AddTraceLog(TCHAR* FormatString, va_list args)
{
	CString String;
	if (_vstprintf(	String.GetBuffer(_vsctprintf(FormatString, args) + 1),
					FormatString, args) < 0) return;
	String.ReleaseBuffer();
	//must lock all other edit interaction including create/destroy
	if (g_TraceCS.Lock()) {
		g_TraceString += String;
		g_TraceCS.Unlock();
	}
	AfxGetApp()->GetMainWnd()->PostMessage(WM_UPDATE_TRACELOG, 0, 0);
}

void AddTraceLog(TCHAR* FormatString, ...)
{
	va_list args;
	va_start(args, FormatString);
	AddTraceLog(FormatString, args);
	va_end(args);
}

HANDLE m_hDriver = NULL;

BOOL InstallAndStartDriver(LPCTSTR DriverName, LPCTSTR ServiceExe)
{
	SC_HANDLE hSrv;
	BOOL bRet = FALSE;
	ServiceManager SM;
	if (SM.GetHandle()) {
		if ((hSrv = CreateService(	SM.GetHandle(), DriverName, DriverName,
									SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER,
									SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
									ServiceExe, NULL, NULL,
									NULL, NULL, NULL)) != NULL) {
			if ((bRet = StartService(hSrv, 0, NULL)) == FALSE) {
				AddTraceLog(_T("APICall=StartService ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
							DriverName, hSrv, GetLastError());
			}
			if (!CloseServiceHandle(hSrv)) {
				AddTraceLog(_T("APICall=CloseServiceHandle ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
							DriverName, hSrv, GetLastError());
			}
		} else if (GetLastError() == ERROR_SERVICE_EXISTS) {
			if ((hSrv = OpenService(SM.GetHandle(), DriverName, SERVICE_ALL_ACCESS)) != NULL) {
				if ((bRet = StartService(hSrv, 0, NULL)) == FALSE) {
					AddTraceLog(_T("APICall=StartService ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
								DriverName, hSrv, GetLastError());
				}
				if (!CloseServiceHandle(hSrv)) {
					AddTraceLog(_T("APICall=CloseServiceHandle ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
								DriverName, hSrv, GetLastError());
				}
			} else {
				AddTraceLog(_T("APICall=OpenService ServiceName=%s Error=%08X\r\n"),
							DriverName, GetLastError());
			}
		} else {
			AddTraceLog(_T("APICall=CreateService ServiceName=%s Error=%08X\r\n"),
						DriverName, GetLastError());
		}
	}
	return bRet;
}

BOOL StartDriver(LPCTSTR DriverName)
{
	SC_HANDLE hSrv;
	BOOL bRet = FALSE;
	ServiceManager SM;
	if (SM.GetHandle()) {
		if ((hSrv = OpenService(SM.GetHandle(), DriverName, SERVICE_ALL_ACCESS)) != NULL) {
			if ((bRet = StartService(hSrv, 0, NULL)) == FALSE) {
				AddTraceLog(_T("APICall=StartService ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
							DriverName, hSrv, GetLastError());
			}
			if (!CloseServiceHandle(hSrv)) {
				AddTraceLog(_T("APICall=CloseServiceHandle ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
							DriverName, hSrv, GetLastError());
			}
		} else {
			AddTraceLog(_T("APICall=OpenService ServiceName=%s Error=%08X\r\n"),
						DriverName, GetLastError());
		}
	}
	return bRet;
}

BOOL UnloadDriver(LPCTSTR DosName, LPCTSTR DosNameGlobal,
						 LPCTSTR DriverName)
{
	SC_HANDLE hSrv;
	SERVICE_STATUS serviceStatus;
	OFSTRUCT of;
	BOOL bReturn = FALSE;
	if (m_hDriver && (m_hDriver != INVALID_HANDLE_VALUE)) {
		CloseHandle(m_hDriver);
		m_hDriver = INVALID_HANDLE_VALUE;
	}
	ServiceManager SM;
	if (SM.GetHandle()) {
		if ((hSrv = OpenService(SM.GetHandle(), DriverName, SERVICE_ALL_ACCESS)) != NULL) {
			if ((bReturn = ControlService(hSrv, SERVICE_CONTROL_STOP, &serviceStatus)) == FALSE) {
				AddTraceLog(_T("APICall=ControlService ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
							DriverName, hSrv, GetLastError());
			}
			if ((bReturn = DeleteService(hSrv)) == FALSE) {
				AddTraceLog(_T("APICall=DeleteService ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
							DriverName, hSrv, GetLastError());
			}
			if (!CloseServiceHandle(hSrv)) {
				AddTraceLog(_T("APICall=CloseServiceHandle ServiceName=%s ServiceHandle=%08X Error=%08X\r\n"),
							DriverName, hSrv, GetLastError());
			}
		} else {
			AddTraceLog(_T("APICall=OpenService ServiceName=%s Error=%08X\r\n"),
						DriverName, GetLastError());
		}
	}
	if (!OpenFile(CT2A(DosName), &of, OF_DELETE)) {
	}
	if (!OpenFile(CT2A(DosNameGlobal), &of, OF_DELETE)) {
	}
	return bReturn;
}

HANDLE LoadDriver(BOOL *fNTDynaLoaded, LPCTSTR DosName,
						 LPCTSTR DosNameGlobal, LPCTSTR DriverName,
						 LPCTSTR ServicePathExe)
{
	HANDLE hDev;
	*fNTDynaLoaded = FALSE;
	hDev = CreateFile(	DosName, GENERIC_READ | GENERIC_WRITE,
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						0, OPEN_EXISTING,
						FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE, 0);
	if (hDev == INVALID_HANDLE_VALUE) {
		hDev = CreateFile(	DosNameGlobal, GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ | FILE_SHARE_WRITE | 
							FILE_SHARE_DELETE, 0, OPEN_EXISTING,
							FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
							0);
		if (hDev == INVALID_HANDLE_VALUE) {
			if (InstallAndStartDriver(	DriverName,
										ServicePathExe)) {
				if ((hDev = CreateFile(	DosNameGlobal, GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ | FILE_SHARE_WRITE |
										FILE_SHARE_DELETE, 0, OPEN_EXISTING,
										FILE_FLAG_OVERLAPPED |
										FILE_FLAG_DELETE_ON_CLOSE,
										0)) == INVALID_HANDLE_VALUE) {
					AddTraceLog(_T("APICall=CreateFile ServiceDosName=%s Error=%08X\r\n"),
								DosName, GetLastError());
				} else {
					*fNTDynaLoaded = TRUE;
				}
			} else {
				AddTraceLog(_T("MyCall=InstallAndStartDriver Error=Unable to install and start driver\r\n"));
			}
		}
	}
	return hDev;
}

#ifdef WIN64
#define ID_DRIVER_RES	ID_BINRESAMD64
#else
#define ID_DRIVER_RES	!PRU_CheckWindowsVersionMinumum(5, 1) ?\
											ID_BINRES2000 :\
											(!PRU_CheckWindowsVersionMinumum(5, 2) ?\
											 ID_BINRESXP : ID_BINRES2003)
#endif

BOOL DriverQueryUnicodeString(DWORD IoControlCode, LPVOID InputBuffer, DWORD InputBufferLength, CStringW & Str)
{
	//start with 2048 characters to avoid having to query the driver more than once
	CByteArray Bytes;
	Bytes.SetSize(sizeof(UNICODE_STRING) + 2048 * sizeof(WCHAR));
	do {
		if (!DriverQuery(	IoControlCode, InputBuffer, InputBufferLength,
							Bytes.GetData(), (DWORD)(DWORD_PTR)Bytes.GetSize())) {
			Str.Empty();
			return FALSE;
		}
		if (((PUNICODE_STRING)Bytes.GetData())->Length > ((PUNICODE_STRING)Bytes.GetData())->MaximumLength) {
			Bytes.SetSize(sizeof(UNICODE_STRING) + ((PUNICODE_STRING)Bytes.GetData())->Length);
		} else {
			((PUNICODE_STRING)Bytes.GetData())->Buffer = (PWSTR)(Bytes.GetData() + sizeof(UNICODE_STRING));
			UniStringToCStringW((PUNICODE_STRING)Bytes.GetData(), Str);
			return TRUE;
		}
	} while (TRUE);
}

BOOL DriverQueryLPWSTRs(DWORD IoControlCode, LPVOID InputBuffer, DWORD InputBufferLength, CStringWArray & Strings)
{
	//start with 8192 characters to avoid having to query the driver more than once
	CByteArray Bytes;
	Bytes.SetSize(sizeof(ULONG) + 0x4000 * sizeof(WCHAR));
	do {
		if (!DriverQuery(	IoControlCode, InputBuffer, InputBufferLength,
							Bytes.GetData(), (DWORD)(DWORD_PTR)Bytes.GetSize())) {
			Strings.RemoveAll();
			return FALSE;
		}
		if (*((ULONG*)Bytes.GetData()) > Bytes.GetSize() - sizeof(ULONG)) {
			Bytes.SetSize(sizeof(ULONG) + *((ULONG*)Bytes.GetData()));
		} else {
			DWORD dwOffset = 0;
			DWORD dwSubCount;
			CStringW Str;
			for (dwSubCount = 0; dwSubCount < *((ULONG*)Bytes.GetData()); dwSubCount++) {
				((PUNICODE_STRING)(Bytes.GetData() + sizeof(ULONG) + dwOffset))->Buffer = (PWSTR)(Bytes.GetData() + sizeof(ULONG) + dwOffset + sizeof(UNICODE_STRING));
				UniStringToCStringW((PUNICODE_STRING)(Bytes.GetData() + sizeof(ULONG) + dwOffset), Str);
				dwOffset += sizeof(UNICODE_STRING) + min(((PUNICODE_STRING)(Bytes.GetData() + sizeof(ULONG) + dwOffset))->Length, ((PUNICODE_STRING)(Bytes.GetData() + sizeof(ULONG) + dwOffset))->MaximumLength);
				Strings.Add(Str);
			}
			return TRUE;
		}
	} while (TRUE);
}

BOOL DriverQuery(DWORD IoControlCode, LPVOID InputBuffer,
						DWORD InputBufferLength, LPVOID OutputBuffer,
						DWORD OutputBufferLength)
{
	HINSTANCE ghInst;
	HRSRC hRsrc;
	HGLOBAL hDrvRsrc;
	DWORD dwDriverSize;
	LPVOID lpvDriver;
	HFILE hfTempFile;
	TCHAR srvexe[MAX_PATH << 4];
	BOOL bLoaded = FALSE;
	DWORD dw;
	OFSTRUCT of;
	if (!m_hDriver || (m_hDriver == INVALID_HANDLE_VALUE)) {
		if ((ghInst = GetModuleHandle(NULL)) != NULL) {
			if (PRU_CheckWindowsVersionMinumum(5, 0) &&
				(hRsrc = FindResource(	ghInst,
										MAKEINTRESOURCE(ID_DRIVER_RES),
										_T("BINRES"))) != NULL) {
				if ((hDrvRsrc = LoadResource(ghInst, hRsrc)) != NULL) {
					if ((dwDriverSize = SizeofResource(ghInst, hRsrc)) != 0) {
						if ((lpvDriver = LockResource(hDrvRsrc)) != NULL) {
							srvexe[0] = 0;
							if (!GetCurrentDirectory(MAX_PATH << 4, srvexe)) {
								AddTraceLog(_T("APICall=GetCurrentDirectory Error=%08X\r\n"),
											GetLastError());
							}
							_tcscat(srvexe, _T("\\") GPD_PESTRIDSYSFILENAME);
							if ((hfTempFile =
									_lcreat(CT2A(srvexe),
											NULL)) != HFILE_ERROR) {
								if (_lwrite(hfTempFile, (char*)lpvDriver,
											dwDriverSize) != HFILE_ERROR) {
									if (_lclose(hfTempFile) == HFILE_ERROR) {
										AddTraceLog(_T("APICall=_lclose File=%s Handle=%08X Error=%08X\r\n"),
													srvexe, hfTempFile,
													GetLastError());
									}
									if ((m_hDriver = LoadDriver(&bLoaded, GPD_DOSDEVICE, GPD_DOSDEVICEGLOBAL, GPD_PESTRIDSERVICENAME, srvexe)) != INVALID_HANDLE_VALUE && m_hDriver && bLoaded) {
									} else {
										AddTraceLog(_T("MyCall=LoadDriver Error=Unable to load driver\r\n"));
									}
									if (!OpenFile(	CT2A(srvexe),
													&of, OF_DELETE)) {
										AddTraceLog(_T("APICall=OpenFile Error=%08X\r\n"),
													GetLastError());
									}
								} else {
									AddTraceLog(_T("APICall=_lwrite File=%s Handle=%08X Error=%08X\r\n"),
												srvexe, hfTempFile,
												GetLastError());
								}
							} else {
								AddTraceLog(_T("APICall=_lcreat File=%s Error=%08X\r\n"),
											srvexe, GetLastError());
							}
						} else {
							AddTraceLog(_T("APICall=LockResource Error=Failed\r\n"));
						}
					} else {
						AddTraceLog(_T("APICall=SizeofResource Error=%08X\r\n"),
									GetLastError());
					}
				} else {
					AddTraceLog(_T("APICall=LoadResource Error=%08X\r\n"),
								GetLastError());
				}
			} else {
				if (PRU_CheckWindowsVersionMinumum(5, 0))
					AddTraceLog(_T("APICall=FindResource Error=%08X\r\n"),
								GetLastError());
			}
		} else {
			AddTraceLog(_T("APICall=GetModuleHandle Error=%08X\r\n"),
						GetLastError());
		}
	}
	if (m_hDriver && (m_hDriver != INVALID_HANDLE_VALUE)) {
		if (DeviceIoControl(m_hDriver, IoControlCode, InputBuffer,
							InputBufferLength, OutputBuffer,
							OutputBufferLength, &dw, NULL)) {
			return TRUE;
		} else {
			AddTraceLog(_T("APICall=DeviceIoControl Error=%08X\r\n"),
						GetLastError());
		}
	}
	return FALSE;
}